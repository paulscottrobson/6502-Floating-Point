
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -a -b -c -o test.bin -L test.lst test.asm
; Wed Jul  3 16:38:01 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: test.asm

.0000	ea		nop				nop
=$08					fpa		= $08 			; 6 byte mantissa/exponent/sign
=$10					fpb		= $10			; 6 byte mantissa/exponent/sign
=$18					fpWork  = $18			; 8 byte temporary work area
=129					fpBias  = 129			; float bias.
=$04					addr 	= $04
.1000					Startup:
.1000	a9 00		lda #$00			lda 	#FPCode & $FF
.1002	85 04		sta $04				sta 	addr
.1004	a9 18		lda #$18			lda 	#FPCode >> 8
.1006	85 05		sta $05				sta 	addr + 1
.1008					CheckLoop:
.1008	b2 04		lda ($04)			lda 	(addr)
.100a	e6 04		inc $04				inc 	addr
.100c	d0 02		bne $1010			bne		NoCarry
.100e	e6 05		inc $05				inc 	addr+1
.1010					NoCarry:
.1010	c9 02		cmp #$02			cmp 	#cmd_f_to_b
.1012	f0 3e		beq $1052			beq 	CopyIn
.1014	c9 01		cmp #$01			cmp 	#cmd_i_to_b
.1016	f0 3a		beq $1052			beq 	CopyIn
.1018	c9 0f		cmp #$0f			cmp 	#cmd_b_to_a
.101a	d0 05		bne $1021			bne 	Skip_Float_COPY_BToA
.101c	20 85 12	jsr $1285			jsr 	Float_COPY_BToA
.101f	80 e7		bra $1008			bra 	CheckLoop
.1021					Skip_Float_COPY_BToA:
.1021	c9 03		cmp #$03			cmp 	#cmd_add
.1023	d0 05		bne $102a			bne 	Skip_Float_ADD
.1025	20 06 12	jsr $1206			jsr 	Float_ADD
.1028	80 de		bra $1008			bra 	CheckLoop
.102a					Skip_Float_ADD:
.102a	c9 04		cmp #$04			cmp 	#cmd_sub
.102c	d0 05		bne $1033			bne 	Skip_Float_SUB
.102e	20 00 12	jsr $1200			jsr 	Float_SUB
.1031	80 d5		bra $1008			bra 	CheckLoop
.1033					Skip_Float_SUB:
.1033	c9 05		cmp #$05			cmp 	#cmd_mul
.1035	d0 05		bne $103c			bne 	Skip_Float_MUL
.1037	20 f8 12	jsr $12f8			jsr 	Float_MUL
.103a	80 cc		bra $1008			bra 	CheckLoop
.103c					Skip_Float_MUL:
.103c	c9 06		cmp #$06			cmp 	#cmd_div
.103e	d0 05		bne $1045			bne 	Skip_Float_DIV
.1040	20 73 13	jsr $1373			jsr 	Float_DIV
.1043	80 c3		bra $1008			bra 	CheckLoop
.1045					Skip_Float_DIV:
.1045	c9 0b		cmp #$0b			cmp 	#cmd_equal0
.1047	f0 2d		beq $1076			beq 	TestNearZero
.1049	c9 0c		cmp #$0c			cmp 	#cmd_exact0
.104b	f0 1e		beq $106b			beq 	TestZero
.104d	c9 10		cmp #$10			cmp 	#cmd_halt
.104f					Error:
.104f	d0 fe		bne $104f			bne 	Error
>1051	02						.byte 	2
.1052	a0 05		ldy #$05	CopyIn:	ldy 	#5
.1054	b1 04		lda ($04),y	_CILoop:lda 	(addr),y
.1056	99 10 00	sta $0010,y			sta 	fpb,y
.1059	88		dey				dey
.105a	10 f8		bpl $1054			bpl 	_CILoop
.105c	a5 04		lda $04				lda 	addr
.105e	18		clc				clc
.105f	69 06		adc #$06			adc 	#6
.1061	85 04		sta $04				sta 	addr
.1063	90 a3		bcc $1008			bcc 	CheckLoop
.1065	e6 05		inc $05				inc 	addr+1
.1067	80 9f		bra $1008			bra 	CheckLoop
.1069	80 fe		bra $1069	w1:		bra 	w1
.106b					TestZero:
.106b	a5 0c		lda $0c				lda 	fpa+4
.106d	f0 99		beq $1008			beq 	CheckLoop
.106f	a9 00		lda #$00			lda 	#0
.1071	a6 04		ldx $04				ldx 	addr
.1073	a4 05		ldy $05				ldy 	addr+1
.1075	ea		nop				nop
.1076					TestNearZero:
.1076	a5 0c		lda $0c				lda 	fpa+4
.1078	f0 8e		beq $1008			beq 	CheckLoop
.107a	38		sec				sec
.107b	e5 14		sbc $14				sbc 	fpb+4
.107d	10 03		bpl $1082			bpl 	_TNZAbs
.107f	49 ff		eor #$ff			eor 	#$FF
.1081	1a		inc a				inc 	a
.1082					_TNZAbs:
.1082	c9 10		cmp #$10			cmp 	#$10
.1084	b0 82		bcs $1008			bcs 	CheckLoop
.1086	a9 01		lda #$01			lda 	#1
.1088	a6 04		ldx $04				ldx 	addr
.108a	a4 05		ldy $05				ldy 	addr+1
.108c	ea		nop				nop
.108d					EH_Overflow:
.108d					EH_DivZero:
.108d	80 fe		bra $108d	Stop:	bra 	Stop

;******  Processing file: floatingpoint.asm

=12					fpaE = fpa + 4 								; addresses of exponents
=20					fpbE = fpb + 4 								; (first 4 bytes is mantissa with bit 31 set if #0)
=13					fpaSign = fpa + 5 							; sign (0 = +ve, 1 = -ve)
=21					fpbSign = fpb + 5
.1200					Float_SUB:
.1200	a5 15		lda $15				lda 	fpbSign 					; flip the sign of the second, and add !
.1202	49 01		eor #$01			eor 	#1
.1204	85 15		sta $15				sta 	fpbSign
.1206					Float_ADD:
.1206	20 a1 12	jsr $12a1			jsr 	Float_NormalizeBoth 		; Normalise fpa/fpb.
.1209					_FA_TestZero:
.1209	a5 14		lda $14				lda 	fpbE 						; if B.E is zero, adding zero, so no change.
.120b	f0 77		beq $1284			beq 	_FA_Exit
.120d	a5 0c		lda $0c				lda 	fpaE 						; if A.E is zero, the result is B
.120f	f0 70		beq $1281			beq 	_FA_CopyBToA
.1211	20 c3 12	jsr $12c3			jsr 	Float_AlignExponents 		; align exponents
.1214	a5 0c		lda $0c				lda 	fpaE 						; if either has zerod out, then go back
.1216	f0 f1		beq $1209			beq 	_FA_TestZero 				; and do zero testing code.
.1218	a5 14		lda $14				lda 	fpbE
.121a	f0 ed		beq $1209			beq 	_FA_TestZero
.121c	a5 0d		lda $0d				lda 	fpaSign 					; different signs.
.121e	c5 15		cmp $15				cmp 	fpbSign
.1220	d0 2e		bne $1250			bne 	_FA_DifferentSigns
.1222	18		clc				clc
.1223	a5 08		lda $08				lda 	fpa+0 						; add together.
.1225	65 10		adc $10				adc 	fpb+0
.1227	85 08		sta $08				sta 	fpa+0
.1229	a5 09		lda $09				lda 	fpa+1
.122b	65 11		adc $11				adc 	fpb+1
.122d	85 09		sta $09				sta 	fpa+1
.122f	a5 0a		lda $0a				lda 	fpa+2
.1231	65 12		adc $12				adc 	fpb+2
.1233	85 0a		sta $0a				sta 	fpa+2
.1235	a5 0b		lda $0b				lda 	fpa+3
.1237	65 13		adc $13				adc 	fpb+3
.1239	85 0b		sta $0b				sta 	fpa+3
.123b	90 0c		bcc $1249			bcc 	_FA_NoShift 				; no overflow, so no need to shift.
.123d	e6 0c		inc $0c				inc 	fpaE 						; bump fpa-E and shift A right
.123f	f0 5d		beq $129e			beq 	Float_Error
.1241	46 0b		lsr $0b				lsr 	fpa+3
.1243	66 0a		ror $0a				ror 	fpa+2
.1245	66 09		ror $09				ror 	fpa+1
.1247	66 08		ror $08				ror 	fpa+0
.1249					_FA_NoShift:
.1249	a5 0b		lda $0b				lda 	fpa+3						; set bit 3.
.124b	09 80		ora #$80			ora 	#$80
.124d	85 0b		sta $0b				sta 	fpa+3
.124f	60		rts				rts
.1250					_FA_DifferentSigns:
.1250	38		sec				sec 								; subtract B from A
.1251	a5 08		lda $08				lda 	fpa+0
.1253	e5 10		sbc $10				sbc 	fpb+0
.1255	85 08		sta $08				sta 	fpa+0
.1257	a5 09		lda $09				lda 	fpa+1
.1259	e5 11		sbc $11				sbc 	fpb+1
.125b	85 09		sta $09				sta 	fpa+1
.125d	a5 0a		lda $0a				lda 	fpa+2
.125f	e5 12		sbc $12				sbc 	fpb+2
.1261	85 0a		sta $0a				sta 	fpa+2
.1263	a5 0b		lda $0b				lda 	fpa+3
.1265	e5 13		sbc $13				sbc 	fpb+3
.1267	85 0b		sta $0b				sta 	fpa+3
.1269	b0 07		bcs $1272			bcs 	_FA_Normalize_Exit 		 	; if A was > B check for zero and exit.
.126b	20 de 12	jsr $12de			jsr 	Float_NegateMantissa 		; negate the actual mantissa
.126e	a5 15		lda $15				lda 	fpbSign 					; and return the sign of fpb
.1270	85 0d		sta $0d				sta 	fpaSign
.1272					_FA_Normalize_Exit:
.1272	a5 08		lda $08				lda 	fpa+0 						; is the mantissa zero ?
.1274	05 09		ora $09				ora 	fpa+1
.1276	05 0a		ora $0a				ora 	fpa+2
.1278	05 0b		ora $0b				ora 	fpa+3
.127a	d0 02		bne $127e			bne 	_FA_NonZero
.127c	85 0c		sta $0c				sta 	fpaE 						; if so, zero the exponent as they are same number
.127e					_FA_NonZero:
.127e	4c a1 12	jmp $12a1			jmp 	Float_NormalizeBoth
.1281					_FA_CopyBToA:
.1281	20 85 12	jsr $1285			jsr 	Float_COPY_BToA
.1284					_FA_Exit:
.1284	60		rts				rts
.1285					Float_COPY_BToA:
.1285	a5 10		lda $10				lda 	fpb+0
.1287	85 08		sta $08				sta 	fpa+0
.1289	a5 11		lda $11				lda 	fpb+1
.128b	85 09		sta $09				sta 	fpa+1
.128d	a5 12		lda $12				lda 	fpb+2
.128f	85 0a		sta $0a				sta 	fpa+2
.1291	a5 13		lda $13				lda 	fpb+3
.1293	85 0b		sta $0b				sta 	fpa+3
.1295	a5 14		lda $14				lda 	fpb+4
.1297	85 0c		sta $0c				sta 	fpa+4
.1299	a5 15		lda $15				lda 	fpb+5
.129b	85 0d		sta $0d				sta 	fpa+5
.129d	60		rts				rts
.129e					Float_Error:
.129e	4c 8d 10	jmp $108d			jmp 	EH_Overflow
.12a1					Float_NormalizeBoth:
.12a1	da		phx				phx
.12a2	a2 08		ldx #$08			ldx 	#fpa 						; normalise FPA
.12a4	20 ae 12	jsr $12ae			jsr 	Float_NormalizeX
.12a7	a2 10		ldx #$10			ldx 	#fpb 						; normalise FPB
.12a9	20 ae 12	jsr $12ae			jsr 	Float_NormalizeX
.12ac	fa		plx				plx
.12ad	60		rts				rts
.12ae					Float_NormalizeX:
.12ae	b5 04		lda $04,x			lda 	4,x 						; exit if exponent is zero, means result is zero.
.12b0	f0 10		beq $12c2			beq 	_FNX_Exit
.12b2					_FNX_Loop:
.12b2	b5 03		lda $03,x			lda 	3,x 						; look at high byte of mantissa
.12b4	30 0c		bmi $12c2			bmi 	_FNX_Exit 					; if high bit set, don't need to normalise.
.12b6	16 00		asl $00,x			asl 	0,x 						; shift the mantissa left
.12b8	36 01		rol $01,x			rol 	1,x
.12ba	36 02		rol $02,x			rol 	2,x
.12bc	36 03		rol $03,x			rol 	3,x
.12be	d6 04		dec $04,x			dec 	4,x 						; decrement the exponent
.12c0	d0 f0		bne $12b2			bne 	_FNX_Loop 					; if we get too small, exponent is zero.
.12c2					_FNX_Exit:
.12c2	60		rts				rts
.12c3					Float_AlignExponents:
.12c3	da		phx				phx
.12c4					_FAE_Loop:
.12c4	a5 0c		lda $0c				lda 	fpaE 						; exponents the same ?
.12c6	c5 14		cmp $14				cmp 	fpbE
.12c8	f0 12		beq $12dc			beq 	_FAE_Exit 					; if the same then exit.
.12ca	a2 08		ldx #$08			ldx 	#fpa 						; if fpaE < fpbE then bump fpa
.12cc	90 02		bcc $12d0			bcc 	_FAE_Shift
.12ce	a2 10		ldx #$10			ldx 	#fpb 						; if fpbE > fpaE then bump fpb
.12d0					_FAE_Shift:
.12d0	56 03		lsr $03,x			lsr 	3,x
.12d2	76 02		ror $02,x			ror 	2,x
.12d4	76 01		ror $01,x			ror 	1,x
.12d6	76 00		ror $00,x			ror 	0,x
.12d8	f6 04		inc $04,x			inc 	4,x 						; increment exponent
.12da	d0 e8		bne $12c4			bne 	_FAE_Loop 					; underflowed, so drop out.
.12dc					_FAE_Exit:
.12dc	fa		plx				plx
.12dd	60		rts				rts
.12de					Float_NegateMantissa:
.12de	38		sec				sec
.12df	a9 00		lda #$00			lda 	#0
.12e1	e5 08		sbc $08				sbc 	fpa+0
.12e3	85 08		sta $08				sta 	fpa+0
.12e5	a9 00		lda #$00			lda 	#0
.12e7	e5 09		sbc $09				sbc 	fpa+1
.12e9	85 09		sta $09				sta 	fpa+1
.12eb	a9 00		lda #$00			lda 	#0
.12ed	e5 0a		sbc $0a				sbc 	fpa+2
.12ef	85 0a		sta $0a				sta 	fpa+2
.12f1	a9 00		lda #$00			lda 	#0
.12f3	e5 0b		sbc $0b				sbc 	fpa+3
.12f5	85 0b		sta $0b				sta 	fpa+3
.12f7	60		rts				rts
.12f8					Float_MUL:
.12f8	20 a1 12	jsr $12a1			jsr 	Float_NormalizeBoth 			; normalize A & B
.12fb	a5 0c		lda $0c				lda 	fpaE 							; check either exponent is zero
.12fd	f0 71		beq $1370			beq 	_FM_Zero 						; because 0 * x = 0
.12ff	a5 14		lda $14				lda 	fpbE
.1301	f0 6d		beq $1370			beq 	_FM_Zero
.1303	a5 0c		lda $0c				lda 	fpaE 							; new exponent = A.E - Bias + B.E
.1305	38		sec				sec
.1306	e9 81		sbc #$81			sbc 	#fpBias
.1308	18		clc				clc
.1309	65 14		adc $14				adc 	fpbE
.130b	85 0c		sta $0c				sta 	fpaE
.130d	a5 0d		lda $0d				lda 	fpaSign 						; work out sign.
.130f	45 15		eor $15				eor 	fpbSign
.1311	85 0d		sta $0d				sta 	fpaSign
.1313	64 18		stz $18				stz 	fpWork 							; zero the upper part of the product (fpWork)
.1315	64 19		stz $19				stz 	fpWork+1 						; the lower part is fpa's Mantissa
.1317	64 1a		stz $1a				stz 	fpWork+2
.1319	64 1b		stz $1b				stz 	fpWork+3 						; the adder is fpb's Mantissa
.131b	5a		phy				phy
.131c	a0 20		ldy #$20			ldy 	#32 							; do 32 times, except the last rotate.
.131e					_FM_Loop:
.131e	a5 08		lda $08				lda 	fpa+0 							; check bit 0 of the product (word.Amantissa)
.1320	6a		ror a				ror 	a
.1321	90 19		bcc $133c			bcc 	_FM_NoAdd 						; if bit 0 clear, don't add, with carry clear
.1323	18		clc				clc 									; add fpb.mantissa to the upper word of product
.1324	a5 10		lda $10				lda 	fpb+0
.1326	65 18		adc $18				adc 	fpWork+0
.1328	85 18		sta $18				sta 	fpWork+0
.132a	a5 11		lda $11				lda 	fpb+1
.132c	65 19		adc $19				adc 	fpWork+1
.132e	85 19		sta $19				sta 	fpWork+1
.1330	a5 12		lda $12				lda 	fpb+2
.1332	65 1a		adc $1a				adc 	fpWork+2
.1334	85 1a		sta $1a				sta 	fpWork+2
.1336	a5 13		lda $13				lda 	fpb+3
.1338	65 1b		adc $1b				adc 	fpWork+3
.133a	85 1b		sta $1b				sta 	fpWork+3
.133c					_FM_NoAdd:
.133c	88		dey				dey 									; done the last, but one.
.133d	f0 13		beq $1352			beq 	_FM_DoneMain
.133f	66 1b		ror $1b				ror 	fpWork+3 						; shifting in the carry - so no LSR here
.1341	66 1a		ror $1a				ror 	fpWork+2
.1343	66 19		ror $19				ror 	fpWork+1
.1345	66 18		ror $18				ror 	fpWork+0
.1347	66 0b		ror $0b				ror 	fpa+3
.1349	66 0a		ror $0a				ror 	fpa+2
.134b	66 09		ror $09				ror 	fpa+1
.134d	66 08		ror $08				ror 	fpa+0
.134f	80 cd		bra $131e			bra 	_FM_Loop
.1351	7a		ply				ply
.1352					_FM_DoneMain:
.1352	7a		ply				ply 									; restore Y
.1353	a5 18		lda $18				lda 	fpWork+0 						; put product.left in mantissa
.1355	85 08		sta $08				sta 	fpa+0
.1357	a5 19		lda $19				lda 	fpWork+1
.1359	85 09		sta $09				sta 	fpa+1
.135b	a5 1a		lda $1a				lda 	fpWork+2
.135d	85 0a		sta $0a				sta 	fpa+2
.135f	a5 1b		lda $1b				lda 	fpWork+3
.1361	85 0b		sta $0b				sta 	fpa+3
.1363	90 0a		bcc $136f			bcc 	_FM_Exit 						; no carry out of add, no fix up.
.1365	66 0b		ror $0b				ror 	fpa+3 							; rotate that carry in.
.1367	66 0a		ror $0a				ror 	fpa+2
.1369	66 09		ror $09				ror 	fpa+1
.136b	66 08		ror $08				ror 	fpa+0
.136d	e6 0c		inc $0c				inc 	fpaE
.136f					_FM_Exit:
.136f	60		rts				rts
.1370					_FM_Zero:
.1370	64 0c		stz $0c				stz 	fpaE 							; return zero.
.1372	60		rts				rts
.1373					Float_DIV:
.1373	20 a1 12	jsr $12a1			jsr 	Float_NormalizeBoth 			; normalize A & B
.1376	a5 14		lda $14				lda 	fpbE 							; division by zero ?
.1378	f0 4b		beq $13c5			beq 	_FD_DivZero
.137a	a5 0c		lda $0c				lda 	fpaE 							; top zero?
.137c	f0 4a		beq $13c8			beq 	_FD_Zero
.137e	ea		nop				nop
.137f	a5 0c		lda $0c				lda 	fpaE 							; exp = e.A-e.B+bias+1
.1381	38		sec				sec
.1382	e5 14		sbc $14				sbc 	fpbE
.1384	18		clc				clc
.1385	69 82		adc #$82			adc 	#(fpBias+1)
.1387	85 0c		sta $0c				sta 	fpaE
.1389	a5 0d		lda $0d				lda 	fpaSign 						; work out sign.
.138b	45 15		eor $15				eor 	fpbSign
.138d	85 0d		sta $0d				sta 	fpaSign
.138f	64 18		stz $18				stz 	fpWork 							; zero work 0..3 (result)
.1391	64 19		stz $19				stz 	fpWork+1
.1393	64 1a		stz $1a				stz 	fpWork+2
.1395	64 1b		stz $1b				stz 	fpWork+3
.1397	64 1c		stz $1c				stz 	fpWork+4 						; set bit shifter 4..7 to $40000000
.1399	64 1d		stz $1d				stz 	fpWork+5
.139b	64 1e		stz $1e				stz 	fpWork+6
.139d	a9 40		lda #$40			lda 	#$40
.139f	85 1f		sta $1f				sta 	fpWork+7
.13a1	5a		phy				phy 									; do 31 times
.13a2	a0 1f		ldy #$1f			ldy 	#31
.13a4					_FD_Loop:
.13a4	88		dey				dey
.13a5	d0 fd		bne $13a4			bne 	_FD_Loop
.13a7	7a		ply				ply
.13a8	18		clc				clc
.13a9	a5 18		lda $18				lda 	fpWork							; put result in fpa, add 1 and normalise.
.13ab	69 01		adc #$01			adc 	#1
.13ad	85 18		sta $18				sta 	fpWork
.13af	a5 19		lda $19				lda 	fpWork+1
.13b1	69 00		adc #$00			adc 	#0
.13b3	85 19		sta $19				sta 	fpWork+1
.13b5	a5 1a		lda $1a				lda 	fpWork+2
.13b7	69 00		adc #$00			adc 	#0
.13b9	85 1a		sta $1a				sta 	fpWork+2
.13bb	a5 1b		lda $1b				lda 	fpWork+3
.13bd	69 00		adc #$00			adc 	#0
.13bf	85 1b		sta $1b				sta 	fpWork+3
.13c1	20 a1 12	jsr $12a1			jsr 	Float_NormalizeBoth
.13c4	60		rts				rts
.13c5					_FD_DivZero:
.13c5	4c 8d 10	jmp $108d			jmp 	EH_DivZero
.13c8					_FD_Zero:
.13c8	60		rts				rts

;******  Return to file: test.asm


;******  Processing file: code.inc

=1					cmd_i_to_b = 1
=2					cmd_f_to_b = 2
=3					cmd_add = 3
=4					cmd_sub = 4
=5					cmd_mul = 5
=6					cmd_div = 6
=7					cmd_int = 7
=8					cmd_frac = 8
=9					cmd_itof = 9
=10					cmd_ftoi = 10
=11					cmd_equal0 = 11
=12					cmd_exact0 = 12
=13					cmd_a_to_buffer = 13
=14					cmd_buffer_to_a = 14
=15					cmd_b_to_a = 15
=16					cmd_halt = 16
.1800					FPCode:
>1800	02 00 00 00 80 83 00			.byte 2,0,0,0,128,131,0                ; f>b  4
>1807	0f					.byte 15                               ; b>a
>1808	02 00 00 00 80 82 00			.byte 2,0,0,0,128,130,0                ; f>b  2
>180f	06					.byte 6                                ; /
>1810	02 00 00 00 80 81 00			.byte 2,0,0,0,128,129,0                ; f>b  1
>1817	0b					.byte 11                               ; =0
>1818	10					.byte 16                               ; halt

;******  Return to file: test.asm

>fffc	00 10						.word	Startup

;******  End of listing
